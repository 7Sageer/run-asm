# C 函数编译与模拟执行工具链

这是一个基于 Python 实现的实验性项目，旨在构建一个完整的工具链，用于自动化地编译、执行和验证 C 语言函数。它无需在本地生成可执行文件，而是在内存中完成从 C 源码到机器码的转换，并在 x86-64 CPU 模拟器中运行，最终比对测试结果。

## 核心功能

- **自动化测试流程**: 从指定的 JSON 数据源 (`humaneval-c-no-syscall.json`) 读取 C 函数及其测试用例。
- **内存中编译**: 将 C 语言函数字符串动态编译为 x86-64 架构的机器码。
- **CPU 模拟执行**: 使用 Unicorn Engine 创建一个虚拟的 x86-64 环境，以执行生成的机器码并获取函数返回值。
- **结果验证**: 自动解析测试用例，将输入参数传递给模拟器，并验证输出结果是否符合预期。

## 实现原理

本项目通过三个核心 Python 脚本协同工作，形成一条清晰的处理流水线：`main.py` -> `compiler.py` -> `emulator.py`。


### 步骤 1: 解析 C 代码 (`main.py`)

- **职责**: 作为流程的入口和编排者。
- **实现**:
    1.  读取 `humaneval-c-no-syscall.json` 文件中的编程题目。
    2.  使用**正则表达式**从 C 代码字符串中解析出**函数签名**（返回类型、函数名、参数类型）和**测试用例**（输入参数和期望输出）。
    3.  这个阶段将非结构化的代码文本转换为程序可以理解的结构化数据。

### 步骤 2: 编译与汇编 (`compiler.py`)

- **职责**: 将 C 源码字符串转换为可执行的机器码。
- **实现**:
    1.  **C 到汇编**: 通过 `subprocess` 模块调用外部 `gcc` 编译器，将 C 代码编译成 AT&T 语法的汇编代码 (`.s` 文件)。为了避免磁盘 I/O 开销，此过程使用临时文件。
    2.  **汇编清理**: `gcc` 生成的汇编包含许多对后续步骤无用或有害的伪指令（如 `.file`, `.ident`, `.cfi_*` 等）。`clean_asm` 函数会移除这些指令，精简代码以提高与汇编器的兼容性。
    3.  **汇编到机器码**: 使用 `keystone-engine` 库将清理后的汇编代码字符串汇编成原生的 x86-64 二进制机器码。

### 步骤 3: 模拟执行 (`emulator.py`)

- **职责**: 创建一个安全、隔离的虚拟环境来执行机器码。
- **实现**:
    1.  **环境设置**: 使用 `unicorn-engine` 创建一个 x86-64 架构的 CPU 模拟器。同时，在模拟器中映射独立的内存区域用于存放**代码** (`.text`)、**数据** (`.data`) 和**堆栈**。
    2.  **参数准备 (ABI 实现)**: 这是模拟执行的核心。`_prepare_args` 函数遵循 **System V AMD64 ABI** (Linux x86-64 的标准函数调用约定) 来处理函数参数：
        -   **整型/指针参数**: 依次放入 `RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9` 寄存器。
        -   **浮点数参数**: 依次放入 `XMM0`, `XMM1`, ... `XMM7` 寄存器。
        -   **指针类型参数**: 将 Python 列表中的数据打包成字节，写入模拟器的“数据段”内存，然后将该内存的地址存入相应的通用寄存器。
    3.  **执行与返回**:
        -   将一个预设的**退出地址**压入模拟堆栈的顶部，然后将机器码写入代码段并开始执行。
        -   当 C 函数执行 `ret` 指令时，CPU 会从堆栈弹出返回地址，恰好是我们预设的“退出地址”，从而使模拟器安全停止。
        -   根据函数签名中的返回类型，从正确的寄存器（整型/指针在 `RAX`，浮点数在 `XMM0`）读取结果。

### 步骤 4: 结果验证 (`main.py`)

- **职责**: 对比模拟执行的结果和测试用例中的期望值。
- **实现**:
    - 获取 `emulator.py` 返回的执行结果。
    - 与从 `c_test` 中解析出的期望值进行比较。对于浮点数，使用带有容差的比较 (`math.isclose`)。
    - 在控制台打印每个测试用例的 `PASSED` 或 `FAILED` 状态。

## 项目结构

```
/
├── demo/
│   ├── compiler.py               # 编译器和汇编器模块
│   ├── emulator.py               # x86-64 模拟器模块
│   ├── main.py                   # 主程序，负责流程编排
│   ├── humaneval-c-no-syscall.json # 数据集，包含 C 函数和测试
│   └── ...
└── README.md                     # 本文档
```

## 如何运行

1.  **安装依赖**:
    ```bash
    pip install keystone-engine unicorn
    ```

2.  **确保环境**:
    - 本项目依赖 `gcc` 进行 C 代码编译。请确保您的系统中已安装 `gcc` 并且可以在命令行中调用。
    - 本项目默认在 x86-64 Linux 环境下开发和测试。

3.  **执行**:
    ```bash
    python3 demo/main.py
    ```

## 项目缺陷与局限性

虽然本项目成功实现了一个复杂的工具链，但作为实验性项目，它存在一些明显的局限性：

1.  **环境强依赖**:
    - **依赖 `gcc`**: 代码硬编码了对 `gcc` 的调用，无法在未安装 `gcc` 的环境运行。
    - **平台特定**: 整个流程隐含地假设了 **x86-64 Linux** 环境，因为它依赖于 `gcc` 的 AT&T 汇编输出和 System V AMD64 调用约定。在 Windows 或 macOS (尤其是 ARM 架构) 上无法直接运行。

2.  **不支持系统调用和标准库 (No `malloc`/`free`)**:
    - **"裸机"模拟**: 模拟器创建的是一个纯净的"裸机"(Bare-metal)环境，其中**没有操作系统**，也没有加载 C 标准库 (`libc`)。
    - **无法处理外部函数**: 因此，任何依赖于标准库的函数（如 `malloc`, `free`, `printf`, `fopen` 等）都无法被解析和执行。这些函数依赖操作系统提供的**系统调用(syscall)**，而这在模拟环境中是不存在的。这也是为什么数据集被特意命名为 `humaneval-c-no-syscall.json` 的原因。
    - **缺少链接步骤**: 工具链只包含**编译**和**汇编**，缺少了**链接**这一步，因此无法解析对外部库函数的引用。

3.  **脆弱的 C 代码解析**:
    - `main.py` 中的解析器完全基于**正则表达式**，它只能处理格式非常规范的简单 C 代码。对于包含复杂类型、宏、注释或不规则格式的代码，解析会失败。一个更健robust的替代方案是使用 `pycparser` 等专业的 C 解析库。

4.  **不完整的 ABI 实现**:
    - `emulator.py` 只实现了通过**寄存器**传递参数。它**不支持通过堆栈传递参数**，这意味着如果一个函数有超过 6 个整型/指针参数或 8 个浮点参数，模拟将会失败。
    - 不支持 `struct` 或 `union` 等复杂数据结构作为参数或返回值。

5.  **汇编清理逻辑脆弱**:
    - `compiler.py` 中的 `clean_asm` 函数依赖一个**硬编码的伪指令列表**。如果使用不同版本或不同品牌的编译器（如 Clang），可能会产生此列表未覆盖的新指令，导致汇编失败。

6.  **固定的内存布局**:
    - 模拟器中的代码、数据和堆栈地址都是硬编码的常量。这对于当前项目是可行的，但缺乏通用性和灵活性。 
