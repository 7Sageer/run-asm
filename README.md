README is generated by LLM

# C 函数编译、执行与分析工具链

这是一个基于 Python 实现的实验性项目，旨在构建一个完整的工具链，用于自动化地编译、执行、验证和分析 C 语言函数及手写汇编代码。项目包含两条主要的工作流水线：

1.  **C 代码验证流水线 (`main.py`)**: 将 C 语言函数在内存中编译为机器码，在 x86-64 CPU 模拟器中执行，并根据提供的测试用例验证其正确性。
2.  **汇编代码执行与分析流水线 (`force_exec.py`)**: 从 JSON 文件中加载手写的汇编代码片段，在模拟器中执行，并输出详细的寄存器和内存状态报告，用于分析代码行为。

## 核心功能

- **自动化测试流程**: 从指定的 JSON 数据源 (`humaneval-c-no-syscall-sample.json` 或 `humaneval-c-all.json`) 读取 C 函数或汇编代码。
- **内存中编译与汇编**: 将 C 函数动态编译为机器码，或将汇编代码字符串直接汇编。
- **CPU 模拟执行**: 使用 Unicorn Engine 创建一个虚拟的 x86-64 环境来执行机器码。
- **结果验证与分析**:
    - `main.py` 自动验证 C 函数的输出是否符合测试用例预期。
    - `force_exec.py` 对汇编代码的执行进行"冒烟测试"，并报告执行后的状态。

## 实现原理

### C 代码验证流水线 (`main.py` -> `compiler.py` -> `emulator.py`)

这条流水线通过三个核心 Python 脚本协同工作，形成一条清晰的处理流程。

#### 步骤 1: 解析 C 代码 (`main.py`)

- **职责**: 作为流程的入口和编排者。
- **实现**:
    1.  读取 `humaneval-c-no-syscall-sample.json` 文件中的编程题目。
    2.  使用正则表达式从 C 代码字符串中解析出函数签名和测试用例。

#### 步骤 2: 编译与汇编 (`compiler.py`)

- **职责**: 将 C 源码字符串转换为可执行的机器码。
- **实现**:
    1.  **C 到汇编**: 通过调用外部 `gcc` 编译器，将 C 代码编译成 AT&T 语法的汇编代码。
    2.  **汇编清理**: 移除 `gcc` 生成的汇编中与模拟执行无关的伪指令。
    3.  **汇编到机器码**: 使用 `keystone-engine` 将清理后的汇编代码汇编成 x86-64 二进制机器码。

#### 步骤 3: 模拟执行与验证 (`emulator.py` 和 `main.py`)

- **职责**: 创建虚拟环境执行机器码并验证结果。
- **实现**:
    1.  **环境设置**: 使用 `unicorn-engine` 创建 x86-64 CPU 模拟器，并映射代码、数据和堆栈内存。
    2.  **参数准备 (ABI 实现)**: `emulator.py` 中的 `_prepare_args` 函数遵循 **System V AMD64 ABI**，将测试用例的输入参数正确加载到模拟器的寄存器和堆栈中。
    3.  **执行与返回**: 执行机器码，并在一个预设的"退出地址"安全停止。根据函数签名从 `RAX` 或 `XMM0` 寄存器读取返回值。
    4.  **结果验证**: `main.py` 对比执行结果与期望值，并打印 `PASSED` 或 `FAILED`。

---

### 新增：汇编代码执行与分析流水线 (`force_exec.py`)

- **职责**: 批量执行 `humaneval-c-all.json` 中提供的汇编代码，并分析其运行时行为。
- **实现**:
    1.  **加载数据**: 读取 `humaneval-c-all.json` 文件，该文件包含了由不同优化等级（O0, O1, O2, O3）编译器生成的汇编代码。
    2.  **汇编代码清洗**:
        -   移除每个代码片段的函数标签（如 `<func0>:`）。
        -   删除行尾的地址提示（如 `<func0+0x28>`），以获得纯净的汇编指令。
        -   脚本内置了一系列强大的清洗函数（如 `replace_calls_and_leas`, `fix_cmp_instruction_size` 等）来处理各种不兼容的汇编语法，使其能够被 `keystone-engine` 正确处理。
    3.  **模拟执行**:
        -   在 `compile_run` 函数中，使用 `unicorn-engine` 创建一个标准的 x86-64 模拟环境。
        -   **使用随机值初始化通用寄存器**（如 `RAX`, `RBX`, `RCX` 等），以进行通用的"冒烟测试"，检查代码在随机输入下的稳定性。
        -   执行清理后的汇编代码。
    4.  **结果报告**:
        -   执行完成后，脚本会详细打印出关键寄存器（`RAX`, `RBX`, `RSP` 等）的最终十六进制值。
        -   同时，它会记录并报告执行期间发生的前几次内存读/写操作的地址、大小和值。
        -   这个过程取代了原有的评估计分逻辑，专注于提供执行状态的快照。

## 项目结构

```
/
├── compiler.py               # 编译器和汇编器模块
├── emulator.py               # x86-64 模拟器模块
├── force_exec.py             # 新增：汇编代码执行与分析脚本
├── main.py                   # C 代码验证流水线主程序
├── humaneval-c-all.json      # 数据集：包含C函数和多种优化等级的汇编
├── humaneval-c-no-syscall-sample.json # 数据集：C函数与测试用例
└── README.md                 # 本文档
```

## 如何运行

1.  **安装依赖**:
    ```bash
    pip install keystone-engine unicorn capstone tqdm
    ```

2.  **确保环境**:
    - 运行 `main.py` 需要 `gcc`。请确保您的系统中已安装 `gcc`。
    - 项目默认在 x86-64 Linux 环境下开发和测试。

3.  **执行**:

    - **运行 C 代码验证流水线**:
      ```bash
      python3 main.py
      ```

    - **运行汇编代码分析流水线**:
      ```bash
      python3 force_exec.py
      ```

## 项目缺陷与局限性

虽然本项目成功实现了一个复杂的工具链，但作为实验性项目，它存在一些明显的局限性：

1.  **环境强依赖**:
    - **依赖 `gcc`**: 代码硬编码了对 `gcc` 的调用，无法在未安装 `gcc` 的环境运行。
    - **平台特定**: 整个流程隐含地假设了 **x86-64 Linux** 环境，因为它依赖于 `gcc` 的 AT&T 汇编输出和 System V AMD64 调用约定。在 Windows 或 macOS (尤其是 ARM 架构) 上无法直接运行。

2.  **不支持系统调用和标准库 (No `malloc`/`free`)**:
    - **"裸机"模拟**: 模拟器创建的是一个纯净的"裸机"(Bare-metal)环境，其中**没有操作系统**，也没有加载 C 标准库 (`libc`)。
    - **无法处理外部函数**: 因此，任何依赖于标准库的函数（如 `malloc`, `free`, `printf`, `fopen` 等）都无法被解析和执行。这些函数依赖操作系统提供的**系统调用(syscall)**，而这在模拟环境中是不存在的。这也是为什么数据集被特意命名为 `humaneval-c-no-syscall-sample.json` 的原因。
    - **缺少链接步骤**: 工具链只包含**编译**和**汇编**，缺少了**链接**这一步，因此无法解析对外部库函数的引用。

3.  **脆弱的 C 代码解析**:
    - `main.py` 中的解析器完全基于**正则表达式**，它只能处理格式非常规范的简单 C 代码。对于包含复杂类型、宏、注释或不规则格式的代码，解析会失败。一个更健robust的替代方案是使用 `pycparser` 等专业的 C 解析库。

4.  **不完整的 ABI 实现**:
    - `emulator.py` 只实现了通过**寄存器**传递参数。它**不支持通过堆栈传递参数**，这意味着如果一个函数有超过 6 个整型/指针参数或 8 个浮点参数，模拟将会失败。
    - 不支持 `struct` 或 `union` 等复杂数据结构作为参数或返回值。

5.  **汇编清理逻辑脆弱**:
    - `compiler.py` 中的 `clean_asm` 函数依赖一个**硬编码的伪指令列表**。如果使用不同版本或不同品牌的编译器（如 Clang），可能会产生此列表未覆盖的新指令，导致汇编失败。

6.  **固定的内存布局**:
    - 模拟器中的代码、数据和堆栈地址都是硬编码的常量。这对于当前项目是可行的，但缺乏通用性和灵活性。 
